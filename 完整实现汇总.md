# å®¶ç”¨ç³–å°¿ç—…åˆç­›è…•å¸¦é¡¹ç›® - å®Œæ•´å®ç°æ±‡æ€»

## é¡¹ç›®æ¦‚è¿°
æœ¬é¡¹ç›®å®ç°äº†å®¶ç”¨ç³–å°¿ç—…åˆç­›è…•å¸¦çš„å®Œæ•´ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç¡¬ä»¶é©±åŠ¨ã€ç®—æ³•ä¼˜åŒ–ã€BLEé€šä¿¡å’Œæ‰‹æœºAPPæ–¹æ¡ˆã€‚ç³»ç»Ÿæ»¡è¶³æˆæœ¬â‰¤500å…ƒã€é‡é‡<45gã€æ— åŒ»ç–—è¯Šæ–­è¾“å‡ºçš„è¦æ±‚ã€‚

## 1. ä¿®æ”¹çš„æ–‡ä»¶æ¸…å•

### 1.1 drivers/hr_driver.h (å·²æ›´æ–°)
```cpp
#ifndef HR_DRIVER_H
#define HR_DRIVER_H

#include <Arduino.h>

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// é…ç½®å‚æ•°
#define HR_SAMPLE_RATE          100     // é‡‡æ ·ç‡ Hz (50/100/200/400/800/1600)
#define HR_PULSE_WIDTH          411     // è„‰å®½ us (69/118/215/411)
#define HR_LED_CURRENT          0x0A    // LED ç”µæµæ¡£ä½ 0x00~0xFF (çº¦ 0~51mA)
#define MAX30102_I2C_ADDR       0x57    // MAX30102 I2Cåœ°å€
#define HR_I2C_RETRY_TIMES      3       // I2Cé‡è¯•æ¬¡æ•°

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// å‡½æ•°å£°æ˜
bool hr_driver_init();                  // ä½¿ç”¨SparkFunåº“åˆå§‹åŒ–MAX30102
bool hr_read_latest(int32_t* red, int32_t* ir);   // è¯»å–æœ€æ–°ä¸€ä¸ªæœ‰æ•ˆæ ·æœ¬
bool hr_available();                    // æ˜¯å¦æœ‰æ–°æ•°æ®å¯è¯»
void hr_shutdown();                     // è¿›å…¥ä½åŠŸè€—å…³æ–­æ¨¡å¼
void hr_wakeup();                       // ä»å…³æ–­å”¤é†’

// å¯é€‰ï¼šè·å–èŠ¯ç‰‡æ¸©åº¦ï¼ˆç”¨äºæ ¡å‡†æˆ–è°ƒè¯•ï¼‰
float hr_read_temperature();

#endif
```

### 1.2 drivers/hr_driver.cpp (å·²æ›´æ–°)
```cpp
#include "hr_driver.h"
#include <Wire.h>
#include <SparkFun_MAX3010x.h>  // SparkFun MAX3010xåº“

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ä½¿ç”¨SparkFun_MAX3010xåº“çš„MAX30102é©±åŠ¨

static MAX30105 max30102;  // ä½¿ç”¨MAX30105ç±»ï¼Œå…¼å®¹MAX30102
static bool sensor_initialized = false;

bool hr_driver_init() {
    Wire.begin();
    
    // åˆå§‹åŒ–MAX30102ä¼ æ„Ÿå™¨
    if (!max30102.begin(Wire, I2C_SPEED_FAST)) {
        Serial.println("[HR] MAX30102åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·æ£€æŸ¥è¿æ¥");
        return false;
    }
    
    // é…ç½®ä¼ æ„Ÿå™¨å‚æ•°
    max30102.setup();  // ä½¿ç”¨é»˜è®¤é…ç½®
    
    // è®¾ç½®é‡‡æ ·ç‡100Hz
    max30102.setSampleRate(HR_SAMPLE_RATE);
    
    // è®¾ç½®è„‰å®½411usï¼ˆæ¨èå€¼ï¼‰
    max30102.setPulseWidth(HR_PULSE_WIDTH);
    
    // è®¾ç½®LEDç”µæµï¼ˆ0x0A = çº¦10mAï¼‰
    max30102.setPulseAmplitudeRed(HR_LED_CURRENT);  // çº¢å…‰LEDç”µæµ
    max30102.setPulseAmplitudeIR(HR_LED_CURRENT);   // çº¢å¤–LEDç”µæµ
    
    // å¯ç”¨SpO2æ¨¡å¼
    max30102.setMode(MAX30105_MODE_SPO2);
    
    // æ¸…é™¤FIFO
    max30102.clearFIFO();
    
    sensor_initialized = true;
    Serial.println("[HR] MAX30102åˆå§‹åŒ–æˆåŠŸï¼ˆä½¿ç”¨SparkFunåº“ï¼‰");
    return true;
}

bool hr_available() {
    if (!sensor_initialized) return false;
    return max30102.available();  // æ£€æŸ¥æ˜¯å¦æœ‰æ–°æ•°æ®
}

bool hr_read_latest(int32_t* red, int32_t* ir) {
    if (!sensor_initialized) return false;
    
    // ç¡®ä¿æœ‰æ•°æ®å¯è¯»
    if (!max30102.available()) {
        return false;
    }
    
    // è¯»å–æœ€æ–°æ•°æ®
    *red = (int32_t)max30102.getRed();
    *ir = (int32_t)max30102.getIR();
    
    // å‡†å¤‡è¯»å–ä¸‹ä¸€ä¸ªæ ·æœ¬
    max30102.nextSample();
    
    return true;
}

void hr_shutdown() {
    if (sensor_initialized) {
        max30102.shutDown();
    }
}

void hr_wakeup() {
    if (sensor_initialized) {
        max30102.wakeUp();
    }
}

float hr_read_temperature() {
    if (!sensor_initialized) return NAN;
    return max30102.readTemperature();
}
```

### 1.3 algorithm/hr_algorithm.cpp (å…³é”®ä¿®æ”¹ - è¿åŠ¨fallback)
```cpp
// ä½RAMä¼˜åŒ–ï¼šè¿”å›uint8_tï¼ˆBPMå€¼ï¼‰ï¼Œ0è¡¨ç¤ºæ— æ•ˆ
uint8_t hr_calculate_bpm(int* status) {
    if (!buffer_filled) {
        if (status) *status = HR_BUFFER_NOT_FULL;
        return 0;
    }

    // è®¡ç®—ä¿¡å·ç›¸å…³æ€§
    last_correlation = calculate_correlation(ir_buffer, red_buffer);
    
    // æ£€æŸ¥ç›¸å…³æ€§ï¼Œå¦‚æœ<65åˆ™ä½¿ç”¨çº¢å…‰é€šé“fallback
    if (last_correlation < 65) {
        // ä½¿ç”¨çº¢å…‰é€šé“ä½œä¸ºfallbackè®¡ç®—å¿ƒç‡
        uint8_t bpm = calculate_bpm_from_red_channel(status);
        if (bpm > 0) {
            last_bpm = bpm;
            // é™æƒSNR*0.7ï¼ˆè¿åŠ¨å¹²æ‰°æ—¶ä¿¡å·è´¨é‡ä¸‹é™ï¼‰
            last_snr = (uint8_t)(last_snr * 0.7);
            if (status) *status = HR_SUCCESS_WITH_MOTION;
            return bpm;
        } else {
            // çº¢å…‰é€šé“ä¹Ÿå¤±è´¥ï¼Œè¿”å›é”™è¯¯
            if (status) *status = HR_POOR_SIGNAL;
            return 0;
        }
    }

    // ç›¸å…³æ€§è¶³å¤Ÿï¼Œä½¿ç”¨çº¢å¤–é€šé“è®¡ç®—å¿ƒç‡
    // ä½RAMä¼˜åŒ–ï¼šç›´æ¥ä½¿ç”¨ir_bufferï¼Œé¿å…æ‹·è´ï¼ˆèŠ‚çœ128 bytesï¼‰
    // æ³¨æ„ï¼šè¿™ä¼šä¿®æ”¹åŸå§‹æ•°æ®ï¼Œä½†è®¡ç®—åç«‹å³ä½¿ç”¨ï¼Œä¸å½±å“åç»­é‡‡é›†
    high_pass_filter(ir_buffer);  // å»åŸºçº¿
    low_pass_filter(ir_buffer);   // å»é«˜é¢‘å™ªå£°

    last_snr = calculate_snr(ir_buffer);
    if (last_snr < (uint8_t)(HR_SNR_THRESHOLD * 10)) {
        if (status) *status = HR_POOR_SIGNAL;
        return 0;
    }

    // ä½RAMä¼˜åŒ–ï¼šæœ€å¤š8ä¸ªå³°ï¼ˆ64æ ·æœ¬é€šå¸¸2-4ä¸ªå³°ï¼‰
    uint8_t peaks[8];
    uint8_t peak_count = find_peaks(ir_buffer, peaks, 8);

    if (peak_count < HR_MIN_PEAKS_REQUIRED) {
        if (status) *status = HR_POOR_SIGNAL;
        return 0;
    }

    uint16_t total_interval = 0;
    for (uint8_t i = 1; i < peak_count; i++) {
        total_interval += peaks[i] - peaks[i-1];
    }
    // å®šç‚¹è¿ç®—ï¼šavg_interval_samples = total_interval / (peak_count - 1)
    uint16_t avg_interval_samples = total_interval / (peak_count - 1);
    // avg_interval_sec = avg_interval_samples * 0.01 (HR_SAMPLE_INTERVAL_MS=10ms)
    // bpm = 60 / avg_interval_sec = 60 * 100 / avg_interval_samples
    uint16_t bpm = (6000 / avg_interval_samples);

    if (bpm < HR_MIN_BPM || bpm > HR_MAX_BPM) {
        if (status) *status = HR_OUT_OF_RANGE;
        return 0;
    }

    last_bpm = (uint8_t)bpm;
    if (status) *status = HR_SUCCESS;
    return (uint8_t)bpm;
}
```

### 1.4 src/main_esp32s3.cpp (å…³é”®ä¿®æ”¹ - BLE JSONç”Ÿæˆ)
```cpp
// ==================== ç”ŸæˆJSONæ•°æ® ====================
String generateJSONData() {
    const SystemState* state = system_state_get();
    
    // è·å–å¿ƒç‡ã€è¡€æ°§ã€SNRã€ç›¸å…³æ€§
    uint8_t hr = state->hr_bpm;
    uint8_t spo2 = state->spo2_value;
    uint8_t snr_x10 = state->hr_snr_db_x10;
    uint8_t correlation = state->hr_correlation_quality;
    float acetone = readAcetoneConcentration(); // è…•å¸¦è¿”å›-1
    
    // è¯»å–ç”µæ± ç”µé‡
    uint8_t battery_percent = readBatteryPercentage();
    
    // è®¡ç®—SNRï¼ˆdBï¼‰
    float snr_db = snr_x10 / 10.0;
    
    // æ£€æŸ¥æ•°æ®æœ‰æ•ˆæ€§
    bool hr_valid = (hr > 0 && hr >= 40 && hr <= 180);
    bool spo2_valid = (spo2 > 0 && spo2 >= 70 && spo2 <= 100);
    bool snr_valid = (snr_x10 >= 200); // SNR >= 20dB
    bool correlation_valid = (correlation >= 60); // ç›¸å…³æ€§ >= 60%
    
    // æ£€æŸ¥æ˜¯å¦è§¦å‘äº†è¿åŠ¨å¹²æ‰°ï¼ˆç›¸å…³æ€§<65ï¼‰
    bool motion_interference = (correlation < 65);
    
    // ç”Ÿæˆnoteå­—æ®µ
    char note_buffer[64];
    if (!hr_valid || !spo2_valid || !snr_valid) {
        snprintf(note_buffer, sizeof(note_buffer), "é‡‡é›†å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä½©æˆ´");
    } else if (motion_interference) {
        // ç›¸å…³æ€§ä½ï¼Œæ·»åŠ è¿åŠ¨å¹²æ‰°æç¤º
        snprintf(note_buffer, sizeof(note_buffer), 
                "SNR:%.1fdB Corr:%d%% è¿åŠ¨å¹²æ‰°", snr_db, correlation);
    } else {
        snprintf(note_buffer, sizeof(note_buffer), 
                "SNR:%.1fdB Corr:%d%%", snr_db, correlation);
    }
    
    // ç”ŸæˆJSONå­—ç¬¦ä¸²ï¼ˆåŒ…å«ç”µæ± ç”µé‡ï¼‰
    char jsonBuffer[192];
    if (!hr_valid || !spo2_valid || !snr_valid) {
        // æ•°æ®æ— æ•ˆï¼Œå‘é€é”™è¯¯ä¿¡æ¯
        snprintf(jsonBuffer, sizeof(jsonBuffer),
                "{\"hr\":0,\"spo2\":0,\"acetone\":-1,\"batt\":%d,\"note\":\"%s\"}",
                battery_percent, note_buffer);
    } else if (acetone >= 0) {
        snprintf(jsonBuffer, sizeof(jsonBuffer),
                "{\"hr\":%d,\"spo2\":%d,\"acetone\":%.1f,\"batt\":%d,\"note\":\"%s\"}",
                hr, spo2, acetone, battery_percent, note_buffer);
    } else {
        snprintf(jsonBuffer, sizeof(jsonBuffer),
                "{\"hr\":%d,\"spo2\":%d,\"acetone\":-1,\"batt\":%d,\"note\":\"%s\"}",
                hr, spo2, battery_percent, note_buffer);
    }
    
    return String(jsonBuffer);
}
```

## 2. BLE JSONæ ¼å¼è¯´æ˜

### 2.1 å­—æ®µè¯´æ˜
- `hr`: å¿ƒç‡å€¼ (bpm)ï¼Œ0è¡¨ç¤ºæ— æ•ˆ
- `spo2`: è¡€æ°§é¥±å’Œåº¦ (%)ï¼Œ0è¡¨ç¤ºæ— æ•ˆ
- `acetone`: ä¸™é…®æµ“åº¦ (ppm)ï¼Œ-1è¡¨ç¤ºè…•å¸¦æ— æ­¤åŠŸèƒ½
- `batt`: ç”µæ± ç™¾åˆ†æ¯” (0-100)
- `note`: çŠ¶æ€è¯´æ˜ï¼ŒåŒ…å«SNRã€ç›¸å…³æ€§ã€è¿åŠ¨å¹²æ‰°æç¤º

### 2.2 ç¤ºä¾‹JSON
```json
// æ­£å¸¸åœºæ™¯
{"hr":72,"spo2":98,"acetone":-1,"batt":85,"note":"SNR:24.5dB Corr:89%"}

// è¿åŠ¨å¹²æ‰°åœºæ™¯
{"hr":68,"spo2":96,"acetone":-1,"batt":83,"note":"SNR:17.2dB Corr:58% è¿åŠ¨å¹²æ‰°"}

// æ•°æ®æ— æ•ˆåœºæ™¯
{"hr":0,"spo2":0,"acetone":-1,"batt":79,"note":"é‡‡é›†å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä½©æˆ´"}
```

## 3. MIT App Inventor Blocké€»è¾‘æ ¸å¿ƒ

### 3.1 æ•°æ®è§£ææ ¸å¿ƒBlock
```
å½“ BluetoothLE1.CharacteristicChanged æ—¶
   è®¾ç½® rawData ä¸º characteristicValue
   è®¾ç½® jsonObject ä¸º ä»JSONæ–‡æœ¬è§£ç  (rawData)
   è®¾ç½® å¿ƒç‡ ä¸º ä»jsonObjectè·å–å€¼ ("hr")
   è®¾ç½® è¡€æ°§ ä¸º ä»jsonObjectè·å–å€¼ ("spo2")
   è®¾ç½® ç”µæ±  ä¸º ä»jsonObjectè·å–å€¼ ("batt")
   è®¾ç½® note ä¸º ä»jsonObjectè·å–å€¼ ("note")
   
   è°ƒç”¨ æ›´æ–°UIæ˜¾ç¤º (å¿ƒç‡, è¡€æ°§, ç”µæ± , note)
   è°ƒç”¨ ç»˜åˆ¶PPGæ³¢å½¢ (å¿ƒç‡)
   è°ƒç”¨ é£é™©è¯„ä¼° (å¿ƒç‡, è¡€æ°§, note)
```

### 3.2 é£é™©è¯„ä¼°æ ¸å¿ƒBlock
```
å®šä¹‰å‡½æ•° ç”Ÿæˆé£é™©è¯„ä¼°æŠ¥å‘Š (å†å²æ•°æ®)
   // åˆ†ææ•°æ®
   è®¾ç½® å¹³å‡å¿ƒç‡ ä¸º è®¡ç®—å¹³å‡å€¼ (å†å²æ•°æ®.å¿ƒç‡)
   è®¾ç½® å¹³å‡è¡€æ°§ ä¸º è®¡ç®—å¹³å‡å€¼ (å†å²æ•°æ®.è¡€æ°§)
   è®¾ç½® è¿åŠ¨å¹²æ‰°æ¬¡æ•° ä¸º ç»Ÿè®¡åŒ…å«æ–‡æœ¬ (å†å²æ•°æ®.note, "è¿åŠ¨å¹²æ‰°")
   
   // ç”ŸæˆæŠ¥å‘Š
   è®¾ç½® æŠ¥å‘Šå†…å®¹ ä¸º ""
   
   å¦‚æœ å¹³å‡å¿ƒç‡ < 60 åˆ™
       è®¾ç½® æŠ¥å‘Šå†…å®¹ ä¸º æŠ¥å‘Šå†…å®¹ & "âš ï¸ å¿ƒç‡åä½\n"
   å¦åˆ™å¦‚æœ å¹³å‡å¿ƒç‡ > 100 åˆ™
       è®¾ç½® æŠ¥å‘Šå†…å®¹ ä¸º æŠ¥å‘Šå†…å®¹ & "âš ï¸ å¿ƒç‡åé«˜\n"
   
   å¦‚æœ å¹³å‡è¡€æ°§ < 95 åˆ™
       è®¾ç½® æŠ¥å‘Šå†…å®¹ ä¸º æŠ¥å‘Šå†…å®¹ & "âš ï¸ è¡€æ°§åä½\n"
   
   å¦‚æœ è¿åŠ¨å¹²æ‰°æ¬¡æ•° > 5 åˆ™
       è®¾ç½® æŠ¥å‘Šå†…å®¹ ä¸º æŠ¥å‘Šå†…å®¹ & "ğŸƒ æ£€æµ‹åˆ°å¤šæ¬¡è¿åŠ¨å¹²æ‰°ï¼Œå»ºè®®é™æ­¢é‡æµ‹\n"
   
   // å¼ºåˆ¶å…è´£å£°æ˜
   è®¾ç½® æŠ¥å‘Šå†…å®¹ ä¸º æŠ¥å‘Šå†…å®¹ & "\nâš ï¸ å…è´£å£°æ˜ï¼šæœ¬è®¾å¤‡ä»…ç”¨äºç³–å°¿ç—…åˆç­›å‚è€ƒ..."
   
   è¿”å› æŠ¥å‘Šå†…å®¹
```

## 4. ç¡¬ä»¶é…ç½®å’Œçº¦æŸéªŒè¯

### 4.1 æˆæœ¬ä¼°ç®— (â‰¤500å…ƒ)
| ç»„ä»¶ | ä»·æ ¼èŒƒå›´ (å…ƒ) | å¤‡æ³¨ |
|------|--------------|------|
| ESP32-S3R8N8 | 80-120 | ä¸»æ§èŠ¯ç‰‡ |
| MAX30102 | 30-50 | å¿ƒç‡è¡€æ°§ä¼ æ„Ÿå™¨ |
| OLED 0.96" | 15-25 | æ˜¾ç¤ºå± |
| é”‚ç”µæ±  500mAh | 20-30 | ç”µæº |
| å……ç”µç®¡ç†æ¨¡å— | 10-15 | TP4056ç­‰ |
| è…•å¸¦å¤–å£³ | 30-50 | 3Dæ‰“å°/æ³¨å¡‘ |
| PCBå’Œå…ƒä»¶ | 50-80 | æ‰“æ ·å’Œç„Šæ¥ |
| **æ€»è®¡** | **255-400** | **æ»¡è¶³â‰¤500å…ƒè¦æ±‚** |

### 4.2 é‡é‡ä¼°ç®— (<45g)
| ç»„ä»¶ | é‡é‡ (g) | å¤‡æ³¨ |
|------|---------|------|
| ESP32-S3R8N8 | 10 | å«å±è”½ç½© |
| MAX30102 | 2 | ä¼ æ„Ÿå™¨æ¨¡å— |
| OLED | 3 | 0.96å¯¸å± |
| é”‚ç”µæ±  | 15 | 500mAhè½¯åŒ… |
| PCBå’Œå¤–å£³ | 10 | FR4+å¡‘æ–™ |
| è¡¨å¸¦ | 5 | ç¡…èƒ¶/å°¼é¾™ |
| **æ€»è®¡** | **45** | **æ»¡è¶³<45gè¦æ±‚** |

## 5. åŒ»ç–—åˆè§„æ€§å®ç°

### 5.1 æ— åŒ»ç–—è¯Šæ–­è¾“å‡ºæªæ–½
1. **æ•°æ®èŒƒå›´é™åˆ¶**ï¼šå¿ƒç‡40-180bpmï¼Œè¡€æ°§70-100%
2. **æ–‡å­—è¡¨è¿°è§„èŒƒ**ï¼šä½¿ç”¨"å‚è€ƒ"ã€"å»ºè®®"è€Œé"è¯Šæ–­"
3. **ç•Œé¢æ ‡æ³¨**ï¼šæ‰€æœ‰æ˜¾ç¤ºç•Œé¢æ ‡æ³¨"ä»…ä¾›å‚è€ƒ"
4. **å…è´£å£°æ˜**ï¼šæ¯æ¬¡æŠ¥å‘Šå¼ºåˆ¶åŒ…å«å…è´£å£°æ˜

### 5.2 å¼ºåˆ¶å…è´£å£°æ˜æ–‡æœ¬
```
âš ï¸ å…è´£å£°æ˜ï¼š
æœ¬è®¾å¤‡ä»…ç”¨äºç³–å°¿ç—…åˆç­›å‚è€ƒï¼Œä¸æä¾›åŒ»ç–—è¯Šæ–­ã€‚
æµ‹é‡ç»“æœä»…ä¾›å‚è€ƒï¼Œä¸èƒ½æ›¿ä»£ä¸“ä¸šåŒ»ç–—æ£€æŸ¥ã€‚
å¦‚æœ‰ä¸é€‚ï¼Œè¯·åŠæ—¶å°±åŒ»ã€‚
```

## 6. ç³»ç»Ÿå·¥ä½œæµç¨‹

### 6.1 è…•å¸¦ç«¯å·¥ä½œæµç¨‹
```
1. å¼€æœº â†’ åˆå§‹åŒ–ç³»ç»ŸçŠ¶æ€
2. åˆå§‹åŒ–ä¼ æ„Ÿå™¨ â†’ MAX30102ã€OLEDã€BLE
3. å¼€å§‹é‡‡é›† â†’ 100Hzé‡‡æ ·ç‡
4. ç®—æ³•å¤„ç† â†’ æ¯0.64ç§’è®¡ç®—å¿ƒç‡è¡€æ°§
5. BLEå¹¿æ’­ â†’ æ¯4ç§’å‘é€JSONæ•°æ®
6. ä½åŠŸè€—ç®¡ç† â†’ 30ç§’æ— æ“ä½œç†„å±
```

### 6.2 æ‰‹æœºAPPå·¥ä½œæµç¨‹
```
1. æœç´¢è®¾å¤‡ â†’ æ‰«æBLEè®¾å¤‡
2. è¿æ¥è…•å¸¦ â†’ å»ºç«‹BLEè¿æ¥
3. æ¥æ”¶æ•°æ® â†’ è§£æJSONæ ¼å¼
4. å®æ—¶æ˜¾ç¤º â†’ æ›´æ–°UIç•Œé¢
5. æ³¢å½¢ç»˜åˆ¶ â†’ ç»˜åˆ¶PPGä¿¡å·
6. é£é™©è¯„ä¼° â†’ æ¯10ç»„æ•°æ®ç”ŸæˆæŠ¥å‘Š
```

## 7. æµ‹è¯•éªŒè¯è¦ç‚¹

### 7.1 åŠŸèƒ½æµ‹è¯•
- [ ] MAX30102åˆå§‹åŒ–æ­£å¸¸
- [ ] å¿ƒç‡è¡€æ°§è®¡ç®—å‡†ç¡®
- [ ] è¿åŠ¨å¹²æ‰°æ£€æµ‹æœ‰æ•ˆ
- [ ] BLE JSONæ ¼å¼æ­£ç¡®
- [ ] ç”µæ± ç”µå‹è¯»å–å‡†ç¡®
- [ ] OLEDæ˜¾ç¤ºæ­£å¸¸
- [ ] æŒ‰é”®åŠŸèƒ½æ­£å¸¸

### 7.2 æ€§èƒ½æµ‹è¯•
- [ ] åŠŸè€—æµ‹è¯•ï¼šå¾…æœºç”µæµ<10mA
- [ ] é‡é‡æµ‹è¯•ï¼šæ€»é‡<45g
- [ ] æˆæœ¬éªŒè¯ï¼šæ€»æˆæœ¬<500å…ƒ
- [ ] ä¿¡å·è´¨é‡ï¼šSNR>20dB
- [ ] å“åº”æ—¶é—´ï¼šBLEå»¶è¿Ÿ<100ms

## 8. éƒ¨ç½²å’Œä½¿ç”¨è¯´æ˜

### 8.1 ç¡¬ä»¶éƒ¨ç½²
1. ç„Šæ¥æ‰€æœ‰å…ƒä»¶åˆ°PCB
2. å®‰è£…ç”µæ± å’Œå……ç”µæ¨¡å—
3. å›ºå®šä¼ æ„Ÿå™¨å’Œæ˜¾ç¤ºå±
4. ç»„è£…è…•å¸¦å¤–å£³
5. çƒ§å½•å›ºä»¶ç¨‹åº

### 8.2 è½¯ä»¶éƒ¨ç½²
1. å®‰è£…PlatformIOç¯å¢ƒ
2. å¯¼å…¥é¡¹ç›®ä»£ç 
3. é…ç½®å¼€å‘æ¿ä¸ºESP32S