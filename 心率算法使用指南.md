# 低RAM占用心率/血氧算法使用指南

## 算法概述

基于MAX30102传感器（I2C地址0x57），使用ESP32-C3或Arduino开发的高效心率/血氧算法。算法针对低RAM环境优化，适用于资源受限的嵌入式系统。

## 核心特性

1. **低RAM占用**：
   - 缓冲区大小：64个样本（仅512字节，原500样本需4000字节）
   - 使用int16_t存储PPG数据（18bit右对齐后截断）
   - 所有浮点运算替换为定点数运算

2. **信号处理**：
   - 采样率：100Hz（每10ms一个样本）
   - 脉宽：411μs
   - LED电流：0x24（约36mA）
   - 高通滤波：截止频率0.5Hz，去除基线漂移
   - 低通滤波：滑动平均窗口9，去除高频噪声

3. **智能检测**：
   - 自适应峰值检测：阈值 = mean + 0.5 * std_dev
   - 快速整数平方根算法（无浮点运算）
   - 信噪比计算：返回SNR*10的uint8_t值
   - 运动干扰判断：SNR < 20dB（即200）标记为信号质量差

4. **心率范围**：
   - 有效范围：40-180 BPM
   - 超出范围标记为无效

## 文件结构

```
algorithm/
├── hr_algorithm.h    # 算法头文件（配置参数和接口）
├── hr_algorithm.cpp  # 算法实现
└── drivers/
    └── hr_driver.h   # MAX30102驱动接口
```

## 配置参数

### hr_algorithm.h 中的关键参数

```cpp
#define HR_BUFFER_SIZE          64      // 缓冲区大小（0.64秒数据）
#define HR_SAMPLE_INTERVAL_MS   10      // 采样间隔（100Hz）
#define HR_MIN_PEAKS_REQUIRED   2       // 最小峰值数
#define HR_MOVING_AVG_WINDOW    9       // 滑动平均窗口
#define HR_PEAK_THRESHOLD_BASE  0.5     // 峰值检测阈值系数
#define HR_MIN_BPM              40      // 最小有效心率
#define HR_MAX_BPM              180     // 最大有效心率
#define HR_SNR_THRESHOLD        20.0    // 信噪比阈值（20dB）
```

### hr_driver.h 中的传感器配置

```cpp
#define HR_SAMPLE_RATE          100     // 采样率 Hz
#define HR_PULSE_WIDTH          411     // 脉宽 us
#define HR_LED_CURRENT          0x24    // LED电流档位
#define HR_FIFO_AVERAGE         4       // 内部平均样本数
```

## 使用示例

### 基本使用流程

```cpp
#include "algorithm/hr_algorithm.h"

void setup() {
    // 1. 初始化心率算法
    hr_algorithm_init();
    
    // 2. 初始化MAX30102传感器（在hr_driver中实现）
    if (!hr_init()) {
        Serial.println("MAX30102初始化失败");
        return;
    }
    
    Serial.println("心率算法初始化完成");
}

void loop() {
    static uint32_t last_update_ms = 0;
    static uint32_t last_calc_ms = 0;
    uint32_t now = millis();
    
    // 3. 每10ms更新数据（100Hz采样率）
    if (now - last_update_ms >= 10) {
        last_update_ms = now;
        
        int status = hr_algorithm_update();
        if (status != HR_SUCCESS) {
            // 处理错误
            if (status == HR_READ_FAILED) {
                Serial.println("传感器读取失败");
            }
        }
    }
    
    // 4. 每2秒计算一次心率
    if (now - last_calc_ms >= 2000) {
        last_calc_ms = now;
        
        int calc_status;
        uint8_t bpm = hr_calculate_bpm(&calc_status);
        
        if (calc_status == HR_SUCCESS) {
            uint8_t snr_x10 = hr_get_signal_quality();
            float snr_db = snr_x10 / 10.0;
            
            Serial.printf("心率: %d BPM, SNR: %.1f dB\n", bpm, snr_db);
            
            // 检查运动干扰
            if (snr_x10 < 200) {  // 20dB * 10
                Serial.println("警告：信号质量差，可能存在运动干扰");
            }
        } else {
            // 处理错误
            switch (calc_status) {
                case HR_BUFFER_NOT_FULL:
                    Serial.println("缓冲区未满");
                    break;
                case HR_POOR_SIGNAL:
                    Serial.println("信号质量差");
                    break;
                case HR_OUT_OF_RANGE:
                    Serial.println("心率超出范围");
                    break;
            }
        }
    }
}
```

### 高级使用：实时监测

```cpp
// 实时心率监测类
class HeartRateMonitor {
private:
    uint8_t bpm_buffer[10];
    uint8_t bpm_index = 0;
    uint8_t valid_count = 0;
    
public:
    void update() {
        // 每10ms调用
        hr_algorithm_update();
    }
    
    bool calculate() {
        int status;
        uint8_t bpm = hr_calculate_bpm(&status);
        
        if (status == HR_SUCCESS) {
            // 存储到缓冲区
            bpm_buffer[bpm_index] = bpm;
            bpm_index = (bpm_index + 1) % 10;
            valid_count = min(valid_count + 1, 10);
            return true;
        }
        return false;
    }
    
    uint8_t get_average_bpm() {
        if (valid_count == 0) return 0;
        
        uint16_t sum = 0;
        for (uint8_t i = 0; i < valid_count; i++) {
            sum += bpm_buffer[i];
        }
        return sum / valid_count;
    }
    
    uint8_t get_signal_quality() {
        return hr_get_signal_quality();  // SNR*10
    }
    
    bool is_signal_good() {
        return hr_get_signal_quality() >= 200;  // SNR >= 20dB
    }
};
```

## 算法原理

### 1. 信号预处理

```cpp
// 高通滤波（去除基线漂移）
// 一阶IIR滤波器，截止频率0.5Hz
// 公式：y[n] = α * (y[n-1] + x[n] - x[n-1])
// α = 243/256 ≈ 0.95（定点数实现）

// 低通滤波（去除高频噪声）
// 滑动平均滤波器，窗口大小9
// 公式：y[n] = (x[n-4] + x[n-3] + ... + x[n+4]) / 9
```

### 2. 峰值检测

```cpp
// 自适应阈值计算
1. 计算信号均值和方差
2. 标准差 = sqrt(方差)（使用快速整数平方根）
3. 阈值 = 均值 + 0.5 * 标准差

// 峰值查找
1. 遍历信号，查找局部最大值
2. 峰值必须大于自适应阈值
3. 记录峰值位置
```

### 3. 心率计算

```cpp
// 基于峰值间隔计算心率
1. 计算相邻峰值的样本间隔
2. 平均间隔 = 总间隔 / (峰值数-1)
3. 心率(BPM) = 60 / (平均间隔 * 0.01)
   = 6000 / 平均间隔
```

### 4. 信噪比计算

```cpp
// 简化SNR计算（定点数实现）
1. 信号幅度 = sqrt(方差)
2. 噪声幅度 ≈ 信号幅度 / 10（经验值）
3. 信噪比(dB) = 20 * log10(信号幅度/噪声幅度)
4. 返回SNR*10（整数，例如20.5dB返回205）
```

## 性能优化

### RAM使用分析

```cpp
// 原始设计（500样本）
int32_t buffer[500] × 4字节 = 2000字节（IR+RED共4000字节）

// 优化设计（64样本）
int16_t buffer[64] × 2字节 = 128字节（IR+RED共256字节）
int16_t red_buffer[64] × 2字节 = 128字节
总计：384字节（节省90%内存）

// 其他变量
uint8_t buffer_pos, last_bpm, last_snr等 ≈ 10字节
总计：< 400字节
```

### 计算复杂度

```cpp
// 每次update（10ms）：
// - 读取传感器数据：I2C通信（约1ms）
// - 存储到缓冲区：O(1)

// 每次calculate（2秒一次）：
// - 高通滤波：O(n)，n=64
// - 低通滤波：O(n×w)，w=9
// - SNR计算：O(n)
// - 峰值检测：O(n)
// - 心率计算：O(p)，p≤8
// 总计：约1000次操作，在100MHz MCU上约10μs
```

## 调试与测试

### 调试输出

启用调试模式查看详细日志：

```cpp
// 在hr_algorithm.h中启用调试
#define HR_DEBUG_ENABLED 1

// 调试输出示例
[HR] 缓冲区已满，开始计算
[HR] SNR: 215 (21.5dB)
[HR] 检测到4个峰值
[HR] 平均间隔: 75样本
[HR] 计算心率: 80 BPM
```

### 信号质量评估

```cpp
// SNR与信号质量对应关系
SNR ≥ 30dB (300): 优秀信号
SNR ≥ 20dB (200): 良好信号（算法要求的最低质量）
SNR ≥ 10dB (100): 一般信号（可能存在运动干扰）
SNR < 10dB (100): 差信号（建议重新测量）

// 常见问题诊断
1. SNR < 200: 传感器接触不良或运动干扰
2. 无峰值检测: 信号幅度太小，检查LED电流
3. 心率超出范围: 可能检测到谐波或噪声
```

### 校准建议

1. **LED电流校准**：
   ```cpp
   // 根据皮肤类型调整LED电流
   #define HR_LED_CURRENT_FAIR_SKIN   0x24  // 浅色皮肤
   #define HR_LED_CURRENT_MEDIUM_SKIN 0x2F  // 中等肤色
   #define HR_LED_CURRENT_DARK_SKIN   0x3F  // 深色皮肤
   ```

2. **阈值调整**：
   ```cpp
   // 如果检测到过多假阳性峰值
   #define HR_PEAK_THRESHOLD_BASE 0.7  // 提高阈值
   
   // 如果检测不到足够峰值
   #define HR_PEAK_THRESHOLD_BASE 0.3  // 降低阈值
   ```

## 集成到完整系统

### 与系统调度器集成

```cpp
#include "system/scheduler.h"

// 创建心率采集任务
SchedulerTask hr_task = {
    .interval_ms = 10,      // 100Hz采样
    .last_run_ms = 0,
    .function = hr_task_function
};

void hr_task_function() {
    hr_algorithm_update();
    
    // 每2秒计算一次
    static uint16_t counter = 0;
    if (++counter >= 200) {  // 10ms × 200 = 2秒
        counter = 0;
        
        int status;
        uint8_t bpm = hr_calculate_bpm(&status);
        
        if (status == HR_SUCCESS) {
            // 更新系统状态
            system_state_set_heart_rate(bpm);
            system_state_set_signal_quality(hr_get_signal_quality());
        }
    }
}
```

### 与BLE通信集成

```cpp
// BLE心率特征值更新
void update_ble_heart_rate() {
    uint8_t bpm = hr_get_latest_bpm();
    uint8_t snr = hr_get_signal_quality();
    
    // 创建数据包
    uint8_t data[3];
    data[0] = bpm;                    // 心率值
    data[1] = snr;                    // 信号质量（SNR×10）
    data[2] = (bpm != 0) ? 1 : 0;     // 有效性标志
    
    // 通过BLE发送
    ble_send_heart_rate(data, 3);
}
```

## 注意事项

1. **传感器放置**：
   - 确保传感器与皮肤良好接触
   - 避免强光直射传感器
   - 测量时保持静止

2. **电源管理**：
   - 测量间隙进入低功耗模式
   - 动态调整采样率（运动时100Hz，静止时50Hz）
   - 根据电池电量调整LED电流

3. **算法限制**：
   - 仅适用于静息心率测量
   - 运动状态下准确度下降
   - 需要至少2秒数据才能计算

4. **医疗免责**：
   - 本算法仅用于生理参数趋势监测
   - 不用于医疗诊断
   - 测量结果仅供参考

## 故障排除

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| 无心率数据 | 传感器未连接 | 检查I2C连接 |
| SNR始终为0 | LED电流太小 | 增加HR_LED_CURRENT |
| 心率值不稳定 | 运动干扰 | 确保测量时静止 |
| 检测不到峰值 | 阈值太高 | 降低HR_PEAK_THRESHOLD_BASE |
| 心率超出范围 | 噪声干扰 | 检查电源噪声，增加滤波 |

## 版本历史

- v1.0 (2026-01-26): 初始版本
  - 低RAM优化设计
  - 定点数运算实现
  - 自适应峰值检测
  - SNR质量评估

## 技术支持

如有问题，请参考：
1. MAX30102数据手册
2. 算法源代码注释
3. 示例程序
4. 调试日志输出

---

**重要声明**：本算法实现仅供参考，不用于医疗诊断。实际使用前请进行充分测试和验证。