# 家用糖尿病初筛腕带项目 - 完整实现汇总

## 项目概述
本项目实现了家用糖尿病初筛腕带的完整系统，包括硬件驱动、算法优化、BLE通信和手机APP方案。系统满足成本≤500元、重量<45g、无医疗诊断输出的要求。

## 1. 修改的文件清单

### 1.1 drivers/hr_driver.h (已更新)
```cpp
#ifndef HR_DRIVER_H
#define HR_DRIVER_H

#include <Arduino.h>

// ──────────────────────────────────────────────
// 配置参数
#define HR_SAMPLE_RATE          100     // 采样率 Hz (50/100/200/400/800/1600)
#define HR_PULSE_WIDTH          411     // 脉宽 us (69/118/215/411)
#define HR_LED_CURRENT          0x0A    // LED 电流档位 0x00~0xFF (约 0~51mA)
#define MAX30102_I2C_ADDR       0x57    // MAX30102 I2C地址
#define HR_I2C_RETRY_TIMES      3       // I2C重试次数

// ──────────────────────────────────────────────
// 函数声明
bool hr_driver_init();                  // 使用SparkFun库初始化MAX30102
bool hr_read_latest(int32_t* red, int32_t* ir);   // 读取最新一个有效样本
bool hr_available();                    // 是否有新数据可读
void hr_shutdown();                     // 进入低功耗关断模式
void hr_wakeup();                       // 从关断唤醒

// 可选：获取芯片温度（用于校准或调试）
float hr_read_temperature();

#endif
```

### 1.2 drivers/hr_driver.cpp (已更新)
```cpp
#include "hr_driver.h"
#include <Wire.h>
#include <SparkFun_MAX3010x.h>  // SparkFun MAX3010x库

// ──────────────────────────────────────────────
// 使用SparkFun_MAX3010x库的MAX30102驱动

static MAX30105 max30102;  // 使用MAX30105类，兼容MAX30102
static bool sensor_initialized = false;

bool hr_driver_init() {
    Wire.begin();
    
    // 初始化MAX30102传感器
    if (!max30102.begin(Wire, I2C_SPEED_FAST)) {
        Serial.println("[HR] MAX30102初始化失败，请检查连接");
        return false;
    }
    
    // 配置传感器参数
    max30102.setup();  // 使用默认配置
    
    // 设置采样率100Hz
    max30102.setSampleRate(HR_SAMPLE_RATE);
    
    // 设置脉宽411us（推荐值）
    max30102.setPulseWidth(HR_PULSE_WIDTH);
    
    // 设置LED电流（0x0A = 约10mA）
    max30102.setPulseAmplitudeRed(HR_LED_CURRENT);  // 红光LED电流
    max30102.setPulseAmplitudeIR(HR_LED_CURRENT);   // 红外LED电流
    
    // 启用SpO2模式
    max30102.setMode(MAX30105_MODE_SPO2);
    
    // 清除FIFO
    max30102.clearFIFO();
    
    sensor_initialized = true;
    Serial.println("[HR] MAX30102初始化成功（使用SparkFun库）");
    return true;
}

bool hr_available() {
    if (!sensor_initialized) return false;
    return max30102.available();  // 检查是否有新数据
}

bool hr_read_latest(int32_t* red, int32_t* ir) {
    if (!sensor_initialized) return false;
    
    // 确保有数据可读
    if (!max30102.available()) {
        return false;
    }
    
    // 读取最新数据
    *red = (int32_t)max30102.getRed();
    *ir = (int32_t)max30102.getIR();
    
    // 准备读取下一个样本
    max30102.nextSample();
    
    return true;
}

void hr_shutdown() {
    if (sensor_initialized) {
        max30102.shutDown();
    }
}

void hr_wakeup() {
    if (sensor_initialized) {
        max30102.wakeUp();
    }
}

float hr_read_temperature() {
    if (!sensor_initialized) return NAN;
    return max30102.readTemperature();
}
```

### 1.3 algorithm/hr_algorithm.cpp (关键修改 - 运动fallback)
```cpp
// 低RAM优化：返回uint8_t（BPM值），0表示无效
uint8_t hr_calculate_bpm(int* status) {
    if (!buffer_filled) {
        if (status) *status = HR_BUFFER_NOT_FULL;
        return 0;
    }

    // 计算信号相关性
    last_correlation = calculate_correlation(ir_buffer, red_buffer);
    
    // 检查相关性，如果<65则使用红光通道fallback
    if (last_correlation < 65) {
        // 使用红光通道作为fallback计算心率
        uint8_t bpm = calculate_bpm_from_red_channel(status);
        if (bpm > 0) {
            last_bpm = bpm;
            // 降权SNR*0.7（运动干扰时信号质量下降）
            last_snr = (uint8_t)(last_snr * 0.7);
            if (status) *status = HR_SUCCESS_WITH_MOTION;
            return bpm;
        } else {
            // 红光通道也失败，返回错误
            if (status) *status = HR_POOR_SIGNAL;
            return 0;
        }
    }

    // 相关性足够，使用红外通道计算心率
    // 低RAM优化：直接使用ir_buffer，避免拷贝（节省128 bytes）
    // 注意：这会修改原始数据，但计算后立即使用，不影响后续采集
    high_pass_filter(ir_buffer);  // 去基线
    low_pass_filter(ir_buffer);   // 去高频噪声

    last_snr = calculate_snr(ir_buffer);
    if (last_snr < (uint8_t)(HR_SNR_THRESHOLD * 10)) {
        if (status) *status = HR_POOR_SIGNAL;
        return 0;
    }

    // 低RAM优化：最多8个峰（64样本通常2-4个峰）
    uint8_t peaks[8];
    uint8_t peak_count = find_peaks(ir_buffer, peaks, 8);

    if (peak_count < HR_MIN_PEAKS_REQUIRED) {
        if (status) *status = HR_POOR_SIGNAL;
        return 0;
    }

    uint16_t total_interval = 0;
    for (uint8_t i = 1; i < peak_count; i++) {
        total_interval += peaks[i] - peaks[i-1];
    }
    // 定点运算：avg_interval_samples = total_interval / (peak_count - 1)
    uint16_t avg_interval_samples = total_interval / (peak_count - 1);
    // avg_interval_sec = avg_interval_samples * 0.01 (HR_SAMPLE_INTERVAL_MS=10ms)
    // bpm = 60 / avg_interval_sec = 60 * 100 / avg_interval_samples
    uint16_t bpm = (6000 / avg_interval_samples);

    if (bpm < HR_MIN_BPM || bpm > HR_MAX_BPM) {
        if (status) *status = HR_OUT_OF_RANGE;
        return 0;
    }

    last_bpm = (uint8_t)bpm;
    if (status) *status = HR_SUCCESS;
    return (uint8_t)bpm;
}
```

### 1.4 src/main_esp32s3.cpp (关键修改 - BLE JSON生成)
```cpp
// ==================== 生成JSON数据 ====================
String generateJSONData() {
    const SystemState* state = system_state_get();
    
    // 获取心率、血氧、SNR、相关性
    uint8_t hr = state->hr_bpm;
    uint8_t spo2 = state->spo2_value;
    uint8_t snr_x10 = state->hr_snr_db_x10;
    uint8_t correlation = state->hr_correlation_quality;
    float acetone = readAcetoneConcentration(); // 腕带返回-1
    
    // 读取电池电量
    uint8_t battery_percent = readBatteryPercentage();
    
    // 计算SNR（dB）
    float snr_db = snr_x10 / 10.0;
    
    // 检查数据有效性
    bool hr_valid = (hr > 0 && hr >= 40 && hr <= 180);
    bool spo2_valid = (spo2 > 0 && spo2 >= 70 && spo2 <= 100);
    bool snr_valid = (snr_x10 >= 200); // SNR >= 20dB
    bool correlation_valid = (correlation >= 60); // 相关性 >= 60%
    
    // 检查是否触发了运动干扰（相关性<65）
    bool motion_interference = (correlation < 65);
    
    // 生成note字段
    char note_buffer[64];
    if (!hr_valid || !spo2_valid || !snr_valid) {
        snprintf(note_buffer, sizeof(note_buffer), "采集失败，请检查佩戴");
    } else if (motion_interference) {
        // 相关性低，添加运动干扰提示
        snprintf(note_buffer, sizeof(note_buffer), 
                "SNR:%.1fdB Corr:%d%% 运动干扰", snr_db, correlation);
    } else {
        snprintf(note_buffer, sizeof(note_buffer), 
                "SNR:%.1fdB Corr:%d%%", snr_db, correlation);
    }
    
    // 生成JSON字符串（包含电池电量）
    char jsonBuffer[192];
    if (!hr_valid || !spo2_valid || !snr_valid) {
        // 数据无效，发送错误信息
        snprintf(jsonBuffer, sizeof(jsonBuffer),
                "{\"hr\":0,\"spo2\":0,\"acetone\":-1,\"batt\":%d,\"note\":\"%s\"}",
                battery_percent, note_buffer);
    } else if (acetone >= 0) {
        snprintf(jsonBuffer, sizeof(jsonBuffer),
                "{\"hr\":%d,\"spo2\":%d,\"acetone\":%.1f,\"batt\":%d,\"note\":\"%s\"}",
                hr, spo2, acetone, battery_percent, note_buffer);
    } else {
        snprintf(jsonBuffer, sizeof(jsonBuffer),
                "{\"hr\":%d,\"spo2\":%d,\"acetone\":-1,\"batt\":%d,\"note\":\"%s\"}",
                hr, spo2, battery_percent, note_buffer);
    }
    
    return String(jsonBuffer);
}
```

## 2. BLE JSON格式说明

### 2.1 字段说明
- `hr`: 心率值 (bpm)，0表示无效
- `spo2`: 血氧饱和度 (%)，0表示无效
- `acetone`: 丙酮浓度 (ppm)，-1表示腕带无此功能
- `batt`: 电池百分比 (0-100)
- `note`: 状态说明，包含SNR、相关性、运动干扰提示

### 2.2 示例JSON
```json
// 正常场景
{"hr":72,"spo2":98,"acetone":-1,"batt":85,"note":"SNR:24.5dB Corr:89%"}

// 运动干扰场景
